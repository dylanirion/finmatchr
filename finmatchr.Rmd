---
title: "finmatchr"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    social: NULL
    theme: paper
    source_code: NULL
runtime: shiny
params:
  neo4j_url: "http://localhost:7474"
  neo4j_user: "neo4j"
  neo4j_pass: "neo4j"
  s3_bucket: "bucket"
  s3_access_key: "minioadmin"
  s3_secret_key: "minioadmin"
  s3_region: ""
  s3_endpoint: "localhost:9000"
  ssl: FALSE
---

Review Match Pairs
=======================================================================

```{r setup, echo = FALSE, cache = F}

if( Sys.which("convert") == "" ) { stop( "`convert` not found, please make sure ImageMagick is installed." ) }

#for some reason I can't see params in s3_to_tmp
pars <- params

#some styling maps
color.map <- c( IS_SAME = '#5CB85CFF', UNSURE = '#F0AD4EFF', NOT_SAME = '#D9534FFF', HAS_ENCOUNTER = '#FFC107FF', HAS_IMAGE = '#FFC107FF', VIRTUAL = '#F2F2F2FF', Event = '#440154FF', Encounter = '#21908CFF', Image = '#FDE725FF' )
font.color.map <- c( Event = '#FFFFFFFF', Encounter = '#FFFFFFFF', Image = '#343434FF' )
font.size.map <- c( IS_SAME = 0, UNSURE = 0, NOT_SAME = 0, HAS_ENCOUNTER = 10, HAS_IMAGE = 10, VIRTUAL = 0 )
font.align.map <- c( IS_SAME = NULL, UNSURE = NULL, NOT_SAME = NULL, HAS_ENCOUNTER = "top", HAS_IMAGE = "top", VIRTUAL = NULL )
physics.map <- c( IS_SAME = T, UNSURE = F, NOT_SAME = F, HAS_ENCOUNTER = F, HAS_IMAGE = F, VIRTUAL = F )
chosen.map <- c( IS_SAME = T, UNSURE = T, NOT_SAME = T, HAS_ENCOUNTER = F, HAS_IMAGE = F, VIRTUAL = T )
smooth.map <- c( IS_SAME = F, UNSURE = F, NOT_SAME = F, HAS_ENCOUNTER = F, HAS_IMAGE = F, VIRTUAL = F )
dashes.map <- c( IS_SAME = F, UNSURE = F, NOT_SAME = F, HAS_ENCOUNTER = T, HAS_IMAGE = T, VIRTUAL = F )

#script to forward keydown to shiny input
#custom handler for simulating on click graph event
# (visSetSelection doesn't seem to trigger the on click defined in the visNetwork)
#custom handlers for updating to and from img indexes
tags$script( HTML(
  paste0( "var keys = {};",
          "var keysEnabled = false;",
          "var graphSelected = false;",
          "$('input').on('focus', function() { ",
          "  keysEnabled = false;",
          "});",
          "$('input').on('blur', function() { ",
          "  if( graphSelected ) { keysEnabled = true; }",
          "});",
          "$(document).on('keydown', function(e) { ",
          "  if( !e.repeat && keysEnabled ) { ",
          "    keys[e.which] = e.type == 'keydown';",
          "    if( keys[37] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    } else if( keys[39] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    } else if( keys[88] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    } else if( keys[67] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    } else if( keys[188] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    } else if( keys[190] && Object.values(keys).filter(Boolean).length == 1 ) { ",
          "      Shiny.setInputValue('keys', keys, {priority: 'event'});",
          "      return false;",
          "    }",
          "  }",
          "});",
          "$(document).on('keyup', function(e) { ",
          "  keys[e.which] = e.type == 'keydown';",
          "  return false;",
          "});",
          "function selectEdge(from, to, label, id) { ",
          "  Shiny.setInputValue('edge_from_id', from, {priority: 'event'});",
          "  Shiny.setInputValue('edge_to_id', to, {priority: 'event'});",
          "  Shiny.setInputValue('edge_label', label, {priority: 'event'});",
          "  Shiny.setInputValue('edge_id', id, {priority: 'event'});",
          "};",
          "Shiny.addCustomMessageHandler('simSelect', function(edge) { ",
          "  selectEdge(edge.from, edge.to, edge.label, edge.id);",
          "});",
          "Shiny.addCustomMessageHandler('setFromImgIDX', function(id) { ",
          "  Shiny.setInputValue('from_img_idx', id, {priority: 'event'});",
          "});",
          "Shiny.addCustomMessageHandler('setToImgIDX', function(id) { ",
          "  Shiny.setInputValue('to_img_idx', id, {priority: 'event'});",
          "});" ) ) )

# create connection to local neo4j database
con <- neo4j_api$new( url = pars$neo4j_url, user = pars$neo4j_user, password = pars$neo4j_pass )

#expose tempdir to shiny server
addResourcePath( prefix = "img", directoryPath = tempdir() )

#function for copying/converting images from s3 to tmpdir
s3_to_tmp <- function( path, uuid ) {
  src <- paste0( tempdir(), "/", basename(path) )
  dest <- paste0( tempdir(), "/", uuid, '.jpg' )
  if( !file.exists( src ) ) {
    save_object( path, bucket = pars$s3_bucket, file = src, base_url = pars$s3_endpoint, region = pars$s3_region, key = pars$s3_access_key, secret = pars$s3_secret_key, use_https = pars$ssl )
  
    #standardize extension if jpg
    if( file_ext( src ) %in% c( 'jpg', 'JPG', 'jpeg', 'JPEG' ) ) {
      file.rename( src, dest )
    } else { #otherwise convert to jpg with Image Magick
      cat( "Converting...\n" )
      system2( "convert", args = paste( "'", src, "' '", dest, "'", sep = "" ) )
    }
  }
}

#setup reactive values
react <- reactiveValues( run = NULL, style = NULL, draw = NULL, update = NULL, copy = NULL, valid_img_count = NULL, unreviewed_img_count = NULL, unreviewed_folder_count = NULL, unreviewed_n_folders = NULL )
payload <- reactiveValues( query = NULL, graph = NULL, original_graph = NULL, from = NULL, to = NULL, from_meta = NULL, to_meta = NULL, edge_meta = NULL, old_from = NULL, old_to = NULL )

#database update functions
update_node <- function( uuid, region, date, unusable, reviewed ) {
  query <- paste0( "MATCH (n {uuid: '", uuid, "'}) SET n.region = '", region, "', n.date = date('", date, "'), n.unusable = ", unusable, ", n.reviewed = ", reviewed )
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  #if unusable = T, detach any propagated IS_SAME relationships
  if( ifelse( unusable == 'null', F, unusable ) ) {
      query <- paste0( "MATCH (n {uuid: '", uuid, "', unusable: true}) ",
                       "OPTIONAL MATCH (n)<-[r:IS_SAME {basis: 'propagated'}]->(:Image) ",
                       "DELETE r" )
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  }
}

update_edge <- function( from_uuids, to_uuids, label, basis, reviewed ) {
  query <- paste0( "MATCH (from:Image), (to:Image) ",
                   "WHERE from.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "'] ",
                   "AND to.uuid IN ['", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "WITH from, to, from AS f, to AS t ",
                   "OPTIONAL MATCH (f)<-[r]->(t) ",
                   "DELETE r ",
                   "MERGE (from)<-[new:", label, "]->(to) ",
                   "SET new.basis = '", basis, "', new.reviewed = ", reviewed )
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  #transitive (triadic) closures (anything greater than 4 is too slow)
  query <- paste0( "MATCH (img1:Image)<-[:IS_SAME*2..3]->(img2:Image) ",
                   "WHERE id(img1) <> id(img2) AND NOT (img1)<-[:IS_SAME]->(img2) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '",paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true ",
                   "MERGE (img1)<-[:IS_SAME {basis: 'propagated'}]->(img2)" )
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  query <- paste0( "MATCH (img2:Image)<-[:IS_SAME*2..3]->(img1:Image)<-[:IS_SAME*2..3]->(img3:Image) ",
                   "WHERE id(img2) <> id(img3) AND NOT (img2)<-[:IS_SAME]->(img3) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '",paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true AND COALESCE(img3.unusable, false) ",
                   "MERGE (img2)<-[:IS_SAME {basis: 'propagated'}]->(img3)" )
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  #do the same but for all reviewed
  query <- paste0( "MATCH (img1:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img2:Image) ",
                   "WHERE id(img1) <> id(img2) AND NOT (img1)<-[:IS_SAME {reviewed: true}|IS_SAME {basis: duplicate}]->(img2) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true ",
                   "MERGE (img1)<-[r:IS_SAME]->(img2) ",
                   "ON CREATE SET r.basis = 'propagated', r.reviewed = true ",
                   "ON MATCH SET r.reviewed = true")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  query <- paste0( "MATCH (img2:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img1:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img3:Image) ",
                   "WHERE id(img2) <> id(img3) AND NOT (img2)<-[:IS_SAME {reviewed: true}]->(img3) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true AND COALESCE(img3.unusable, false) ",
                   "MERGE (img2)<-[r:IS_SAME]->(img3) ",
                   "ON CREATE SET r.basis = 'propagated', r.reviewed = true ",
                   "ON MATCH SET r.reviewed = true")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  #and four more for NOT_SAME
  query <- paste0( "MATCH (img1:Image)-[:NOT_SAME]->(:Image)<-[:IS_SAME*2..3]->(img2:Image) ",
                   "WHERE id(img1) <> id(img2) AND NOT (img1)<-[:NOT_SAME|IS_SAME]->(img2) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true ",
                   "MERGE (img1)<-[r:NOT_SAME {basis: propagated}]->(img2) ")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  query <- paste0( "MATCH (img2:Image)<-[:IS_SAME*2..3]->(img1:Image)-[:NOT_SAME]->(:Image)<-[:IS_SAME*2..3]->(img3:Image) ",
                   "WHERE id(img2) <> id(img3) AND NOT (img2)<-[:NOT_SAME|IS_SAME]->(img3) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true AND COALESCE(img3.unusable, false) ",
                   "MERGE (img2)<-[r:NOT_SAME {basis: propagated}]->(img3) ")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  query <- paste0( "MATCH (img1:Image)-[:NOT_SAME {reviewed: true}]->(:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img2:Image) ",
                   "WHERE id(img1) <> id(img2) AND NOT (img1)<-[:NOT_SAME {reviewed: true}|IS_SAME]->(img2) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true ",
                   "MERGE (img1)<-[r:NOT_SAME]->(img2) ",
                   "ON CREATE SET r.basis = 'propagated', r.reviewed = true ",
                   "ON MATCH SET r.reviewed = true")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
  
  query <- paste0( "MATCH (img2:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img1:Image)-[:NOT_SAME {reviewed: true}]->(:Image)<-[:IS_SAME*2..3 {reviewed: true}]->(img3:Image) ",
                   "WHERE id(img2) <> id(img3) AND NOT (img2)<-[:NOT_SAME {reviewed: true}|IS_SAME]->(img3) ",
                   "AND img1.uuid IN ['", paste0( from_uuids, collapse = "', '" ), "', '", paste0( to_uuids, collapse = "', '" ), "'] ",
                   "AND COALESCE(img1.unusable, false) <> true AND COALESCE(img2.unusable, false) <> true AND COALESCE(img3.unusable, false) ",
                   "MERGE (img2)<-[r:NOT_SAME]->(img3) ",
                   "ON CREATE SET r.basis = 'propagated', r.reviewed = true ",
                   "ON MATCH SET r.reviewed = true")
  cat( "QUERY: ", query, "\n" )
  query %>% call_neo4j( con )
}

#function to embed image as svg and return svgPanZoom
draw_img <- function( uuid ) {
  svgPanZoom( paste0( "<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><image width = '750' height = '500' xlink:href='img/", uuid,".jpg'/></svg>" ),
              controlIconsEnabled = TRUE )
}

#LISTENERS

#"query_n_unreviewed" button click
# sets "query" payload
# triggers "run" with increment
query_n_unreviewed_action <- observeEvent( input$query_n_unreviewed, {
  n <- 10
  react$draw <- NULL
  payload$graph = NULL
  payload$query <- paste0( "MATCH (img1:Image)-[rel]-(img2:Image) ",
                          "WHERE rel.reviewed <> true OR rel.reviewed IS NULL ",
                          "WITH COLLECT(img1) + COLLECT(img2) AS imgs ",
                          "UNWIND imgs AS img ",
                          "WITH img LIMIT ", n,
                          " OPTIONAL MATCH (img:Image)-[rel:HAS_IMAGE]-(enc:Encounter) ",
                          "WITH enc, COLLECT(img) + COLLECT(enc) AS n, COLLECT(rel) AS r ",
                          "OPTIONAL MATCH (enc:Encounter)-[rel:HAS_ENCOUNTER]-(evt:Event) ",
                          "WITH n + COLLECT(evt) AS nodes, r + COLLECT(rel) AS relationships ",
                          "RETURN nodes, relationships" )
  react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
})

#"query_by_folder_path" button click
# sets "query" payload from select input
# triggers "run" with increment
query_by_folder_path_action <- observeEvent( input$run_folder_query, {
  react$draw <- NULL
  payload$graph = NULL
  payload$query <- paste0( "MATCH (img1:Image)<-[:HAS_IMAGE]-(:Folder {path: '", input$query_by_folder_path, "'}) ",
                         "WITH img1 ",
                         "OPTIONAL MATCH (img1)<-[rel:IS_SAME]->(img2:Image) WHERE rel.basis IN ['duplicate', 'cropped'] ",
                         "WITH COLLECT(id(img1)) + COLLECT(id(img2)) AS ids, COLLECT(img1) + COLLECT(img2) AS imgs, COLLECT(rel) AS r ",
                         "UNWIND imgs AS img ",
                         "WITH img, ids, r ",
                         "OPTIONAL MATCH (img)<-[rel1:HAS_IMAGE]-(enc:Encounter) ",
                         "WITH ids, enc, COLLECT(img) + COLLECT(enc) AS n, r + COLLECT(rel1) AS r ",
                         "OPTIONAL MATCH (enc)<-[rel:HAS_ENCOUNTER]-(evt:Event) ",
                         "WITH ids, n + COLLECT(evt) AS nodes, r + COLLECT(rel) AS relationships ",
                         "OPTIONAL MATCH (a)-[r]->(b) WHERE id(a) IN ids AND id(b) IN ids ",
                         "RETURN nodes, COLLECT(r) + relationships AS realtionships" )
  react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
})

#"run_manual_query" button click
# sets "query" payload from text input
# triggers "run" with increment
manual_query_action <- observeEvent( input$run_manual_query, {
  react$draw <- NULL
  payload$graph = NULL
  payload$query <- input$manual_query
  react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
})

#"run" reactive
# executes "query" payload
# processes response as "graph" payload
# triggers "style" with increment
run_query <- observeEvent( react$run, {
  payload$old_from <- payload$from_meta$id
  payload$old_to <- payload$to_meta$id
  payload$from_meta <- NULL
  payload$to_meta <- NULL
  payload$edge_meta <- NULL
  # query db with progress bar         
  withProgress(message = 'Querying Database...', value = 0, {
    
    # increment progress bar
    incProgress(0.5)
    
    # query data from neo4j
    cat( "QUERY: ", payload$query, "\n" )
    graph <- payload$query %>% call_neo4j( con, type = "graph" )
  
    #@todo: move all this into a function
    if( length(graph) ) { #@todo: renderText() somehow if there are no results?
      # add potentially empty property columns
      node_cols <- tibble( unusable = NA, reviewed = NA, date = NA_character_, camera_date = NA_character_ )
      edge_cols <- tibble( basis = NA_character_, reviewed = NA_real_ )
      # unnest nodes
      graph$nodes <- graph$nodes %>% 
        unnest_nodes( what = "properties" ) %>%
        select( -contains( 'loc' ) ) %>%
        distinct() %>%
        mutate( label = graph$nodes$label %>% unlist() %>% .[ . != "DUMMY" ] ) %>%
        add_column( !!!node_cols[!names( node_cols ) %in% names(.)] )
    
      # unnest relationships
      if( !is.null( graph$relationships ) ) {
        graph$relationships <- graph$relationships %>%
          unnest_relationships() %>%
          rename( from = startNode, to = endNode, label = type ) %>%
          add_column( !!!edge_cols[!names( edge_cols ) %in% names(.)] )
      }
      #pseudonodes from relationships (nested tibble)
      igraph_object<- graph_from_data_frame( d = graph$relationships %>% filter( label == "IS_SAME" & basis %in% c( "duplicate", "cropped" ) & reviewed == T ) %>% select( from, to, everything() ), directed = F, vertices = graph$nodes )
      
      comp <- groups( components( igraph_object ) ) %>% map_df( ~ tibble( id = as.character(md5(paste0( sort( . ), collapse = ", ") ) ), members = list(.) ) )
      graph$nodes <- graph$nodes %>%
        mutate( group = comp[components( igraph_object )$membership, "id"] %>% .$id ) %>%
        nest( data = !group ) %>%
        select( id = group, data ) %>%
        mutate( label = map_chr( data, ~unique( .$label ) ) )
      
      #drop the relationships we grouped
      graph$relationships <- graph$relationships %>%
        rowwise() %>%
        mutate( keep = map2_lgl( from, to, ~ !any( sapply( comp$members, function(e) is.element( .x, e ) & is.element( .y, e ) ) ) ),
                from = comp[which( sapply( comp$members, function(e) is.element( from, e ) ) ), "id"] %>% .$id,
                to = comp[which( sapply( comp$members, function(e) is.element( to, e ) ) ), "id"] %>% .$id ) %>%
        ungroup() %>%
        filter( keep ) %>% select( -keep )
      
      #remove 'unusable' nodes (but re-add later)
      unusable <- graph$nodes %>% mutate( unusable = map_lgl( data, ~all( .$unusable == T ) ) ) %>% filter( unusable == T ) %>% select( -unusable ) 
      graph$nodes <- graph$nodes %>% mutate( unusable = map_lgl( data, ~all( .$unusable == T ) ) ) %>% filter( unusable != T | is.na(unusable) ) %>% select( -unusable )
      
      if( graph$nodes %>% filter( label == "Image" ) %>% nrow() > 1 ) {
        #create virtual relationships for any that aren't present
        virtual_rels <- t( combn( graph$nodes %>% filter( label == "Image" ) %>% .$id, 2 ) ) %>%
        `colnames<-`( c( "from", "to" ) ) %>% as_tibble() %>%
          mutate( label = "VIRTUAL", basis = NA_character_, reviewed = F )
        
        #if no real relationships, just add them all
        if( is.null( graph$relationships ) ) {
          graph$relationships <- virtual_rels
          } else { #otherwise we need to join only those that don't exist
            graph$relationships <- bind_rows( graph$relationships,
                                              anti_join( virtual_rels, bind_rows( graph$relationships %>% filter( label %in% c( "IS_SAME", "UNSURE", "NOT_SAME" ) ),
                                                                                  graph$relationships %>% filter( label %in% c( "IS_SAME", "UNSURE", "NOT_SAME" ) ) %>%
                                                                                    rename( "from" = "to", "to" = "from" ) ),
                                                         by = c( "from", "to" ) ) )
            }
        #rewrite edge ids
        graph$relationships <- graph$relationships %>%
          rowwise() %>%
          mutate( id = as.character( md5(paste0( label, basis, sort( c( from, to ) ), collapse = ", ") ) ) ) %>%
          ungroup() %>%
          distinct(id, .keep_all = T)
      }
      
      #re-add unusable nodes
      graph$nodes <- bind_rows( graph$nodes, unusable )
      
      #sort edges
      graph$relationships <- graph$relationships %>% rowwise %>% mutate( sort = paste0( sort( c( from, to ) ), collapse = ", ") ) %>% ungroup() %>% arrange(sort) %>% select( -sort )
      
      payload$graph <- graph
      
      #trigger styling
      react$style <- ifelse( is.null( react$style ), 0, react$style + 1 )
    }
  })
})

#"style" reactive
# styles and update "graph" payload
# triggers "draw" on first drawing, or "update" with increment
style_results <- observeEvent( react$style, {
  graph <- payload$graph
  graph$nodes <- graph$nodes %>%
    mutate( shape = "circle",
            color.background = recode( label, !!!color.map ),
            font.color = recode( label, !!!font.color.map ),
            #title = case_when( label == 'Event' ~ paste0( '<p><b>', uuid, '</b><br>', date, '</p>' ), label == 'Encounter' ~ paste0( '<p><b>', uuid, '</b><br>', date, '</p>' ), label == 'Image' ~ paste0( '<p><b>', uuid, '</b><br>', source_file, '<br>', camera_date, '<br>', date, '</p>' ) )
            )
  graph$relationships <- graph$relationships %>%
    #filter( label != "NOT_SAME" ) %>%
    mutate( color.color = recode( label, !!!color.map ),
            dashes = recode( label, !!!dashes.map ),
            font.size = recode( label, !!!font.size.map ),
            font.align = recode( label, !!!font.align.map ),
            physics = recode( label, !!!physics.map ),
            chosen = recode( label, !!!chosen.map ),
            smooth.enabled = recode( label, !!!smooth.map ) )
  payload$graph <- graph
  #if we haven't drawn the graph yet, do so, otherwise update it
  if( is.null( react$draw ) ) {
    react$draw <- T
  } else {
    react$update <- ifelse( is.null( react$update ), 0, react$update + 1 )
  }
})

#"draw" reactive
# displays "graph" payload
# adds click actions to trigger inputs
# triggers finishedDrawing reactive
# returns visNetwork
draw_results <- eventReactive( react$draw, {
  graph <- payload$graph
  react$copy <- ifelse( is.null( react$copy ), 0, react$copy + 1 )
  visNetwork( graph$nodes, graph$relationships, height = '100%',
              submain = paste0( nrow( graph$relationships %>% filter( reviewed == T ) ), "/", nrow( graph$relationships %>% filter( label %in% c( 'IS_SAME', 'UNSURE', 'NOT_SAME', 'VIRTUAL' ) ) ), " Edges Reviewed" ) ) %>%
  visEvents( type = "on",
             click = paste0( "function(p) { ",
                             "  keysEnabled = true;",
                             "  graphSelected = true;",
                             "  selectEdge(this.body.data.edges.get(p.edges[0]).from, ",
                             "    this.body.data.edges.get(p.edges[0]).to, ",
                             "    this.body.data.edges.get(p.edges[0]).label, ",
                             "    this.body.data.edges.get(p.edges[0]).id",
                             "  );",
                             "}" ),
             selectEdge = paste0( "function() { keysEnabled = true; graphSelected = true; }" ),
             deselectEdge = paste0( "function() { keysEnabled = false; graphSelected = false; }" ) ) %>%
    visInteraction( dragNodes = F,
                    navigationButtons = T,
                    selectConnectedEdges = F )
}, ignoreInit = T )

#"update" reactive
# displays "graph" payload
# updates VisNetworkProxy
update_results <- observeEvent( react$update, {
  graph <- payload$graph
  #if a node was grouped, and thus our edge changed, try to find a new one
  #@todo: could probably look for another duplicate or cropped here
  if( length( which( graph$relationships$id == input$edge_id ) ) ) {
    i <- which( graph$relationships$id == input$edge_id )
  } else if( is.null(payload$old_from) | is.null(payload$old_to) ) {
    new <- graph$nodes %>%
      mutate( keep = map_lgl( data, ~ ifelse( is.null(payload$old_from), payload$old_to, payload$old_from ) %in% .$id )  ) %>%
      filter( keep ) %>% select( id ) %>% .$id
    i <- which( graph$relationships$id == graph$relationships %>%
                  filter( ( from == new | to == new ) ) %>% slice(1) %>% .$id ) 
  } else {
    a <- graph$nodes %>%
      mutate( keep = map_lgl( data, ~ payload$old_from %in% .$id )  ) %>%
      filter( keep ) %>% select( id ) %>% .$id
    b <- graph$nodes %>%
        mutate( keep = map_lgl( data, ~ payload$old_to %in% .$id )  ) %>%
      filter( keep ) %>% select( id ) %>% .$id  
    i <- which( graph$relationships$id == graph$relationships %>%
                  filter( ( from == a | to == a ) & ( from == b | to == b ) ) %>% slice(1) %>% .$id ) 
  }
  visNetworkProxy( "graph" ) %>%
    visUpdateNodes(graph$nodes) %>%
    visUpdateEdges( graph$relationships ) %>%
    visRemoveEdges( payload$original_graph$relationships$id[which( !payload$original_graph$relationships$id %in% graph$relationships$id )] ) %>%
    visRemoveNodes( payload$original_graph$nodes$id[which( !payload$original_graph$nodes$id %in% graph$nodes$id )] ) %>%
    visSetTitle( submain = paste0( nrow( graph$relationships %>% filter( reviewed == T ) ), "/", nrow( graph$relationships %>% filter( label %in% c( 'IS_SAME', 'UNSURE', 'NOT_SAME', 'VIRTUAL' ) ) ), " Edges Reviewed" ) ) %>%
    visSetSelection( edgesId = graph$relationships$id[i] )
  session$sendCustomMessage( "simSelect", list( from = graph$relationships$from[i],
                                                to = graph$relationships$to[i],
                                                label = graph$relationships$label[i],
                                                id = graph$relationships$id[i] ) )
  session$sendCustomMessage( "setFromImgIDX", ifelse( is.null(payload$old_from), 1, input$from_img_idx ) )
  session$sendCustomMessage( "setToImgIDX", ifelse( is.null(payload$old_to), 1, input$to_img_idx ) )
})

#"copy" reactive
# copies/converts images to tempdir on new graph draw
start_copy <- observeEvent( react$copy, {
  nodes <- payload$graph$nodes %>%
    filter( label == "Image" ) %>%
    select( -id, -label ) %>%
    unnest( cols = c(data) )
  withProgress( message = paste0( 'Copying Images...[1/', nrow(nodes), ']' ), value = 0, {
    for( i in 1:nrow( nodes ) ) {
      # increment progress bar
      setProgress( i / nrow(nodes), message = paste0( 'Copying Images...[', i, '/', nrow(nodes), ']' ) )
      s3_to_tmp( nodes$source_file[i], nodes$uuid[i] )
    }
  })
})

#"edge_id" (input) reactive
# sets from/to/edge _meta payloads
watch_graph_click <- observeEvent( input$edge_id, {
  if( !input$edge_label %in% c( 'HAS_ENCOUNTER', 'HAS_IMAGE' ) ) {
    payload$from <- payload$graph$nodes %>% filter( id == input$edge_from_id ) %>% select( -id, -label ) %>% unnest( cols = c(data) )
    payload$to <- payload$graph$nodes %>% filter( id == input$edge_to_id )  %>% select( -id, -label ) %>% unnest( cols = c(data) )
    payload$edge_meta <- payload$graph$relationships %>% filter( id == input$edge_id )
    cat( "Edge Select: ", input$edge_id, "\n" )
  }
})

#"from" reactive
# sets from viewer img index
from <- observeEvent( payload$from, {
  session$sendCustomMessage( "setFromImgIDX", 1 )
})

# "from_img_idx" (input) reactive
# populates from viewer
# updates input field values from meta
# return svgPanZoom 
draw_from <- eventReactive( input$from_img_idx, {
  payload$from_meta <- payload$from %>% slice( input$from_img_idx )
  img <- payload$from_meta
  output$from_id <- renderText({ paste0( img %>% .$uuid, " [", input$from_img_idx, "/", nrow(payload$from), "]" ) })
  output$from_path <- renderText({ img %>% .$source_file })
  output$from_exif_date <- renderText({ img %>% .$camera_date })
  updateDateInput( session, "from_date", label = NULL, value = img %>% .$date )
  updateCheckboxInput( session, "from_unusable", label = NULL, value = ifelse( is.na( img %>% .$unusable ), F, img %>% .$unusable ) )
  updateCheckboxInput( session, "from_reviewed", label = NULL, value = ifelse( is.na( img %>% .$reviewed ), F, img %>% .$reviewed ) )
  updateTextInput( session, "from_region", label = NULL, value = img %>% .$region )
  return( draw_img( img %>% .$uuid ) )
})

#"to" reactive
# sets to viewer img index
from <- observeEvent( payload$to, {
  session$sendCustomMessage( "setToImgIDX", 1 )
})

# "to_img_idx" (input) reactive
# populates to viewer
# updates input field values from meta
# return svgPanZoom 
draw_to <- eventReactive( input$to_img_idx, {
  payload$to_meta <- payload$to %>% slice( input$to_img_idx )
  img <- payload$to_meta
  output$to_id <- renderText({ paste0( img %>% .$uuid, " [", input$to_img_idx, "/", nrow(payload$to), "]" ) })
  output$to_path <- renderText({ img %>% .$source_file })
  output$to_exif_date <- renderText({ img %>% .$camera_date })
  updateDateInput( session, "to_date", label = NULL, value = img %>% .$date )
  updateCheckboxInput( session, "to_unusable", label = NULL, value = ifelse( is.na( img %>% .$unusable ), F, img %>% .$unusable ) )
  updateCheckboxInput( session, "to_reviewed", label = NULL, value = ifelse( is.na( img %>% .$reviewed ), F, img %>% .$reviewed ) )
  updateTextInput( session, "to_region", label = NULL, value = img %>% .$region )
  return( draw_img( img %>% .$uuid ) )
})

#"edge_meta" reactive
# populates edge viewer
# updates input values from meta
draw_classification <- observeEvent( payload$edge_meta, {
  updateRadioButtons( session, "label", label = NULL, choices = NULL, selected = ifelse( payload$edge_meta$label == "VIRTUAL", "UNSURE", payload$edge_meta$label ) )
    updateSelectInput( session, "basis", label = NULL, choices = NULL, selected = ifelse( is.na( payload$edge_meta$basis ), "", payload$edge_meta$basis ) )
    updateCheckboxInput( session, "reviewed", label = NULL, value = ifelse( is.na( payload$edge_meta$reviewed ), F, payload$edge_meta$reviewed ) )
})

#"save_from" (input) reactive
# updates node in database if any property values have changed
# triggers re-execution of "query" payload
# and update of graph
update_from <- observeEvent( input$save_from, {
  if( !is.null(payload$from_meta) ) {
    if( input$from_region != payload$from_meta$region | input$from_date != payload$from_meta$date | input$from_unusable != ifelse( is.na( payload$from_meta$unusable ), F, payload$from_meta$unusable ) | input$from_reviewed != ifelse( is.na( payload$from_meta$reviewed ), F, payload$from_meta$reviewed ) ) {
      withProgress( message = "Updating Database...", value = 0, {
        payload$original_graph <- payload$graph
        update_node( payload$from_meta$uuid, input$from_region, input$from_date, ifelse( input$from_unusable == F, "null", input$from_unusable ), ifelse( input$from_reviewed == F, "null", input$from_reviewed ) )
        react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
      })
    }
  }
})

#"save_to" (input) reactive
# updates node in database if any properties have changed
# triggers re-execution of "query" payload
# and update of graph
update_to <- observeEvent( input$save_to, {
  if( !is.null(payload$to_meta) ) {
    if( input$to_region != payload$to_meta$region | input$to_date != payload$to_meta$date | input$to_unusable != ifelse( is.na( payload$to_meta$unusable ), F, payload$to_meta$unusable ) | input$to_reviewed != ifelse( is.na( payload$to_meta$reviewed ), F, payload$to_meta$reviewed ) ) {
      withProgress( message = "Updating Database...", value = 0.5, {
        payload$original_graph <- payload$graph
        update_node( payload$to_meta$uuid, input$to_region, input$to_date, ifelse( input$to_unusable == F, "null", input$to_unusable ), ifelse( input$to_reviewed == F, "null", input$to_reviewed ) )
        react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
      })
    }
  }
})

#"classify_label" (input) reactive
# updates edge in database
# triggers re-execution of "query" payload
# and update of graph
update_classification <- observeEvent( input$classify_label, {
  withProgress( message = "Updating Database...", value = 0.5, {
    payload$original_graph <- payload$graph
    update_edge( payload$from$uuid, payload$to$uuid, input$label, input$basis, input$reviewed )
    react$run <- ifelse( is.null( react$run ), 0, react$run + 1 )
  })
})

#"keydown" (input) reactive
# L/R arrows navigate edges (skipping to next unreviewed if present)
# simulates graph select on prev/next arrow keydown (this then populates edge viewer)
# 'x','c' navigate 'from' images for grouped sets
# ',','.' navigate 'to' images for grouped sets
keydown <- observeEvent( input$keys, {
  if( ifelse( is.null( input$keys$`37` ), F, input$keys$`37` ) | ifelse( is.null( input$keys$`39` ), F, input$keys$`39` ) ) { #L/R arrows
    relationships <- payload$graph$relationships %>% filter( label %in% c( 'IS_SAME', 'UNSURE', 'NOT_SAME', 'VIRTUAL' ) )
    i <- which( relationships$id == input$edge_id )
    unreviewed_i <- which( relationships$reviewed != T | is.na( relationships$reviewed )  )
    if( ifelse( is.null( input$keys$`37` ), F, input$keys$`37` ) ) {  # left arrow
      if( length(unreviewed_i) > 0 ) {
        i <- ifelse(  i >= max(unreviewed_i), min(unreviewed_i), unreviewed_i[which( unreviewed_i >= i + 1 )][1] )
      } else {
        i <- ifelse(  i == 1, length( relationships$id ), i - 1 )
      }
    } else if( ifelse( is.null( input$keys$`39` ), F, input$keys$`39` ) ) {  # right arrow
      if( length(unreviewed_i) > 0 ) {
        i <- ifelse(  i <= min(unreviewed_i), max(unreviewed_i), rev(unreviewed_i[which( unreviewed_i <= i - 1 )])[1] )
      } else {
        i <- ifelse( i == length( relationships$id ), 1, i + 1 )
      }
    }
    visNetworkProxy( "graph" ) %>% visSetSelection( edgesId = relationships$id[i] )
    #can't get on click to fire through visSetSelection, so doing manually
    session$sendCustomMessage( "simSelect", list( from = relationships$from[i], to = relationships$to[i], label = relationships$label[i], id = relationships$id[i] ) )
  } else if( ifelse( is.null( input$keys$`88` ), F, input$keys$`88` ) | ifelse( is.null( input$keys$`67` ), F, input$keys$`67` ) ) {
    nodes <- payload$from
    j <- input$from_img_idx
    if( ifelse( is.null( input$keys$`88` ), F, input$keys$`88` ) ) {  # x
      j <- ifelse(  j == 1, length( nodes$id ), j - 1 )
    } else if( ifelse( is.null( input$keys$`67` ), F, input$keys$`67` ) ) {  # c
      j <- ifelse( j == length( nodes$id ), 1, j + 1 )
    }
    session$sendCustomMessage( "setFromImgIDX", j )
  } else if( ifelse( is.null( input$keys$`188` ), F, input$keys$`188` ) | ifelse( is.null( input$keys$`190` ), F, input$keys$`190` ) ) {
    nodes <- payload$to
    j <- input$to_img_idx
    if( ifelse( is.null( input$keys$`188` ), F, input$keys$`188` ) ) {  # <
      j <- ifelse(  j == 1, length( nodes$id ), j - 1 )
    } else if( ifelse( is.null( input$keys$`190` ), F, input$keys$`190` ) ) {  # >
      j <- ifelse( j == length( nodes$id ), 1, j + 1 )
    }
    session$sendCustomMessage( "setToImgIDX", j )
  }
})

#"refresh" (input) reactives
# updates "Database Statistics" section
# populates and triggers folder_list
db_stats <- observeEvent( input$refresh, {
  withProgress( message = "Calculating Statistics...", value = 0, {
    img_count_query <- paste0( "MATCH (img:Image) ",
                               "WHERE COALESCE(img.unusable, false) <> true ",
                               "WITH COUNT(img) AS c ",
                               "RETURN c" )
    cat( "QUERY: ", img_count_query, "\n" )
    react$valid_img_count <- img_count_query %>% call_neo4j( con, type = "row" ) %>% .$c %>% .$value
    setProgress( value = 1/3 )
    
    unreviewed_img_count_query <- paste0( "MATCH (img:Image) ",
                                          "WHERE COALESCE(img.unusable, false) <> true AND COALESCE(img.reviewed, false) <> true ",
                                          "WITH COUNT(img) AS c ",
                                          "RETURN c" )
    cat( "QUERY: ", unreviewed_img_count_query, "\n" )
    react$unreviewed_img_count <- unreviewed_img_count_query %>% call_neo4j( con, type = "row" ) %>% .$c %>% .$value

    setProgress( value = 2/3 )
    
    unreviewed_folder_count_query <- paste0( "MATCH (i:Image)<-[:HAS_IMAGE]-(f:Folder)<-[:HAS_FOLDER*]-(p:Folder) ",
                                             "WHERE COALESCE(i.unusable, false) <> true ",
                                             ## COMMENT BELOW TO SEARCH ALL FOLDERS, NOT JUST MOSSEL BAY
                                             "AND p.name = 'MB' ",
                                             ##
                                             "WITH f, COUNT(i) AS usable, COLLECT(id(i)) AS ids ",
                                             "WHERE SIZE([ (i)<-[:HAS_IMAGE]-(f) WHERE COALESCE(i.reviewed, false) = true | i ] ) <> usable ",
                                             "OR SIZE( [ (a)-[r]->(b) WHERE id(a) IN ids AND id(b) IN ids AND COALESCE(r.reviewed, false) = true | r ] ) < ( usable * ( usable - 1 ) ) / 2 ",
                                             "RETURN f.path")
    cat( "QUERY: ", unreviewed_folder_count_query, "\n" )
    unreviewed_folders <-  unreviewed_folder_count_query %>% call_neo4j( con, type = "row" )
    react$unreviewed_folder_count <- unreviewed_folders$f.path %>% nrow()
    #@todo: how to return nested lists for grouped select?
    react$unreviewed_n_folders <- unreviewed_folders$f.path$value[1:10]
  })
}, ignoreNULL = F, ignoreInit = T )

#"folder_list" reactive
# populates select dropdown
folder_listener <- observeEvent( react$unreviewed_n_folders, {
  updateSelectInput( session, "query_by_folder_path", label = NULL, choices = react$unreviewed_n_folders )
})

# OUTPUTS
output$valid_images <- renderText({ react$valid_img_count })
output$unreviewed_images <- renderText({ react$unreviewed_img_count })
output$unreviewed_folders <- renderText({ react$unreviewed_folder_count })
output$graph <- renderVisNetwork({ draw_results() })
output$from_image <- renderSvgPanZoom({ draw_from() })
output$to_image <- renderSvgPanZoom({ draw_to() })

```

Inputs 1{.sidebar} 
-------------------------------------

###### Database Statistics:
```{r, sidebar stats, echo = FALSE, cache = F}
#Statistics
div( "Valid Images: ", textOutput( "valid_images", inline = T ) )
div( "Unreviewed Images: ", textOutput( "unreviewed_images", inline = T ) )
div( "Unreviewed Folders: ", textOutput( "unreviewed_folders", inline = T ) )
actionLink( "refresh", label = "Refresh" )
```

##### Select an action:

```{r, sidebar actions, echo = FALSE, cache = F}
#Sidebar Inputs
textAreaInput( "manual_query", "Query")
br()
actionButton( "run_manual_query", label = "Run Query" )
hr()
selectInput( "query_by_folder_path", "Select a Folder", choices = "" )
actionButton( "run_folder_query", label = "Query Folder" )
hr()
actionButton( "query_n_unreviewed", label = "Query Next 10 Unreviewed" )
```

Row {data-height=350}
-----------------------------------------------------------------------

### Graph Explorer

```{r, graph explorer, echo = FALSE, cache = F}

visNetworkOutput( "graph" )

```

Row {data-height=650}
-----------------------------------------------------------------------

### Match Viewer

```{r, match viewer, echo =  FALSE, cache = F}

fillRow( height = 650, flex = c( 2, 1, 2 ),
         fillCol( flex = c( 1, 1, 1, 1, 1, 7, 1 ),
                  fillRow( flex = c( 1, 3 ),
                           "Image UUID: ", textOutput( "from_id", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Image path: ", textOutput( "from_path", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "EXIF date: ", textOutput( "from_exif_date", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Date: ", dateInput( "from_date", label = NULL, value = NA ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Region: ", textInput( "from_region", label = NULL, value = NULL ) ),
                  svgPanZoomOutput( "from_image" ),
                  fillRow( flex = c( 2, 2, 2 ), checkboxInput( "from_unusable", "Unusable" ), checkboxInput( "from_reviewed", "Reviewed" ), actionButton( "save_from", "Update" ) ) ),
         fillCol( fillRow( flex = c( 1, 3, 1 ), "", "Classification", "" ),
                  fillRow( flex = c( 1, 3, 1 ), "", radioButtons( "label", label = NULL, choices = c( "IS SAME" = "IS_SAME", "UNSURE" = "UNSURE", "NOT SAME" = "NOT_SAME" ), selected = "UNSURE" ), "" ),
                  fillRow( flex = c( 1, 5, 1 ), "", selectInput( "basis", "Basis",
                                                                 choices = c( "", "notch match" = "notch match", "pigment match" = "pigment match", "burst image" = "burst image", "tag presence" = "tag presence", "duplicate" = "duplicate", "cropped" = "cropped", "propagated" = "propagated" ) ), "" ),
                  fillRow( flex = c( 1, 3, 1 ), "", checkboxInput( "reviewed", "Reviewed" ), "" ),
                  fillRow( flex = c( 1, 3, 1 ), "", actionButton( "classify_label", "Submit" ), "" ) ),
         fillCol( flex = c( 1, 1, 1, 1, 1, 7, 1 ),
                  fillRow( flex = c( 1, 3 ),
                           "Image UUID: ", textOutput( "to_id", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Image path: ", textOutput( "to_path", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "EXIF date: ", textOutput( "to_exif_date", inline = T ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Date: ", dateInput( "to_date", label = NULL, value = NA ) ),
                  fillRow( flex = c( 1, 3 ),
                           "Region: ", textInput( "to_region", label = NULL, value = NULL ) ),
                  svgPanZoomOutput( "to_image" ),
                  fillRow( flex = c( 2, 2, 2 ), checkboxInput( "to_unusable", "Unusable" ), checkboxInput( "to_reviewed", "Reviewed" ), actionButton( "save_to", "Update" ) ) )
         )

```


